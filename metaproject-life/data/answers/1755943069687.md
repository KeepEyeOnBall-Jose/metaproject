Private answer: Identify and remove dead code

(Stored privately; not shown here.)

Approaches:
- Static analysis: use tools (ruff, pyflakes, pylint for Python) to find unused imports/variables and unreachable code warnings.
- Compiler/Linker warnings: for compiled languages the linker often warns about unreferenced symbols.
- Runtime coverage: run test suite with coverage (coverage.py, nyc) to find unexecuted code paths.
- Call graph analysis: use tools that build call graphs (pyan, go-callvis, jdeps) to find isolated functions/classes.
- Staged removal: mark candidate code as deprecated, run tests and monitor for errors, then remove.

Workflow:
1. Generate test coverage and identify low/no-coverage files.
2. Run static analysis and grep to detect symbols with no references.
3. Build a list of candidates and perform manual review.
4. Remove behind a feature-flag or in a branch and run extended tests.

I can run coverage/static analysis on a chosen project if you point me to it.
